"""
SCL Language Executor/Interpreter

This module implements the execution engine for SCL programs by traversing
the parse tree generated by scl_parser.py and executing the statements.

Key Components:
- RuntimeEnvironment: Manages variable storage, function definitions, and scope
- Expression: Evaluates expressions (arithmetic, logical, function calls)
- Statement: Executes different statement types
- Program: Main class with load() and run() methods

Author: Tyler Stroud
"""

import json
import sys
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field


class RuntimeError(Exception):
    """Exception raised for runtime errors during execution"""
    pass


@dataclass
class StructType:
    """Represents a struct type definition"""
    name: str
    fields: Dict[str, str]  # field_name -> type_name


@dataclass
class StructInstance:
    """Represents an instance of a struct"""
    struct_type: str
    fields: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Pointer:
    """Represents a pointer to a value"""
    address: int  # Simulated memory address
    value: Any = None


class RuntimeEnvironment:
    """
    Manages the runtime environment including variables, functions, and memory.

    This class maintains:
    - Variable storage with scoping
    - Function definitions
    - Struct type definitions
    - Dynamic memory management (simulated heap)
    """

    def __init__(self):
        self.global_scope = {}  # Global variables
        self.local_scopes = []  # Stack of local scopes for function calls
        self.functions = {}  # Function definitions
        self.struct_types = {}  # Struct type definitions
        self.type_aliases = {}  # Type aliases (definetype)
        self.heap = {}  # Simulated heap memory
        self.next_address = 1000  # Starting address for heap allocations

    def push_scope(self):
        """Push a new local scope onto the stack"""
        self.local_scopes.append({})

    def pop_scope(self):
        """Pop the current local scope from the stack"""
        if self.local_scopes:
            self.local_scopes.pop()

    def declare_variable(self, name: str, var_type: str, value: Any = None):
        """Declare a variable in the current scope"""
        current_scope = self.local_scopes[-1] if self.local_scopes else self.global_scope

        # Initialize based on type
        if value is None:
            value = self._default_value(var_type)

        current_scope[name] = value

    def _default_value(self, var_type: str):
        """Get default value for a type"""
        if var_type in ['integer', 'long']:
            return 0
        elif var_type in ['double', 'float']:
            return 0.0
        elif var_type == 'char':
            return '\0'
        elif var_type == 'boolean':
            return False
        elif var_type == 'string':
            return ""
        elif var_type.startswith('array'):
            return []
        elif var_type.startswith('pointer'):
            return None
        else:
            return None

    def get_variable(self, name: str) -> Any:
        """Get variable value, searching from local to global scope"""
        # Search local scopes from innermost to outermost
        for scope in reversed(self.local_scopes):
            if name in scope:
                return scope[name]

        # Search global scope
        if name in self.global_scope:
            return self.global_scope[name]

        raise RuntimeError(f"Undefined variable: {name}")

    def set_variable(self, name: str, value: Any):
        """Set variable value in the appropriate scope"""
        # Search local scopes from innermost to outermost
        for scope in reversed(self.local_scopes):
            if name in scope:
                scope[name] = value
                return

        # Search global scope
        if name in self.global_scope:
            self.global_scope[name] = value
            return

        # If not found, set in current scope
        current_scope = self.local_scopes[-1] if self.local_scopes else self.global_scope
        current_scope[name] = value

    def define_struct(self, name: str, fields: Dict[str, str]):
        """Define a struct type"""
        self.struct_types[name] = StructType(name, fields)

    def create_struct_instance(self, struct_name: str) -> StructInstance:
        """Create an instance of a struct type"""
        if struct_name not in self.struct_types:
            raise RuntimeError(f"Undefined struct type: {struct_name}")

        struct_type = self.struct_types[struct_name]
        instance = StructInstance(struct_name)

        # Initialize fields with default values
        for field_name, field_type in struct_type.fields.items():
            instance.fields[field_name] = self._default_value(field_type)

        return instance

    def allocate_memory(self, type_name: str) -> int:
        """Allocate memory on the heap and return address"""
        address = self.next_address
        self.next_address += 1

        # Create instance based on type
        if type_name in self.struct_types:
            value = self.create_struct_instance(type_name)
        else:
            value = self._default_value(type_name)

        self.heap[address] = value
        return address

    def deallocate_memory(self, address: int):
        """Deallocate memory at the given address"""
        if address in self.heap:
            del self.heap[address]
        else:
            raise RuntimeError(f"Invalid memory address: {address}")

    def dereference(self, address: int) -> Any:
        """Dereference a pointer to get the value"""
        if address in self.heap:
            return self.heap[address]
        raise RuntimeError(f"Invalid memory dereference: {address}")

    def define_function(self, name: str, params: List, return_type: str, body: Any):
        """Define a function"""
        self.functions[name] = {
            'params': params,
            'return_type': return_type,
            'body': body
        }

    def get_function(self, name: str):
        """Get function definition"""
        if name in self.functions:
            return self.functions[name]
        raise RuntimeError(f"Undefined function: {name}")


class Expression:
    """
    Evaluates expressions in the parse tree.

    Handles:
    - Literals (numbers, strings, booleans)
    - Variables
    - Arithmetic operations (+, -, *, /)
    - Comparison operations (==, !=, <, >, <=, >=)
    - Logical operations (&&, ||, !)
    - Function calls
    - Pointer operations (address-of, dereference)
    - Struct member access
    """

    def __init__(self, env: RuntimeEnvironment, executor):
        self.env = env
        self.executor = executor

    def evaluate(self, node: Dict) -> Any:
        """Evaluate an expression node and return its value"""
        if node is None:
            return None

        node_type = node.get('type')
        value = node.get('value')
        children = node.get('children', [])

        # Literals
        if node_type == 'NUMBER':
            return int(value)
        elif node_type == 'FLOAT_NUMBER':
            return float(value)
        elif node_type == 'STRING':
            return str(value)
        elif node_type == 'IDENTIFIER':
            return self.env.get_variable(value)

        # Arithmetic operators
        elif node_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']:
            return self._evaluate_binary_op(node_type, children)

        # Comparison operators
        elif node_type in ['EQ', 'NEQ', 'LT', 'GT', 'LE', 'GE']:
            return self._evaluate_comparison(node_type, children)

        # Logical operators
        elif node_type in ['AND', 'OR', 'NOT']:
            return self._evaluate_logical(node_type, children)

        # Address operation
        elif node_type == 'ADDRESS':
            # This is the "address" keyword - simulate getting address
            # In a real implementation, this would return a memory address
            # For simulation, we create a pseudo-address
            return f"&address"

        # Pointer operations
        elif node_type == 'ADDRESSOF':
            # Get address of variable
            var_name = children[0].get('value')
            # In our simulation, we'll allocate if needed
            return self.env.allocate_memory('address')

        elif node_type == 'DEREFERENCE':
            # Dereference pointer
            address = self.evaluate(children[0])
            return self.env.dereference(address)

        # Struct member access (arrow operator)
        elif node_type == 'ARROW':
            struct_ptr = self.evaluate(children[0])
            member_name = children[1].get('value')

            if isinstance(struct_ptr, int):  # It's an address
                struct_instance = self.env.dereference(struct_ptr)
            else:
                struct_instance = struct_ptr

            if isinstance(struct_instance, StructInstance):
                return struct_instance.fields.get(member_name)
            raise RuntimeError(f"Cannot access member of non-struct")

        # Default: return the value
        return value

    def _evaluate_binary_op(self, op_type: str, children: List) -> Any:
        """Evaluate binary arithmetic operation"""
        if len(children) < 2:
            raise RuntimeError(f"Binary operation requires 2 operands")

        left = self.evaluate(children[0])
        right = self.evaluate(children[1])

        if op_type == 'PLUS':
            return left + right
        elif op_type == 'MINUS':
            return left - right
        elif op_type == 'MULTIPLY':
            return left * right
        elif op_type == 'DIVIDE':
            if right == 0:
                raise RuntimeError("Division by zero")
            return left / right

    def _evaluate_comparison(self, op_type: str, children: List) -> bool:
        """Evaluate comparison operation"""
        if len(children) < 2:
            raise RuntimeError(f"Comparison requires 2 operands")

        left = self.evaluate(children[0])
        right = self.evaluate(children[1])

        if op_type == 'EQ':
            return left == right
        elif op_type == 'NEQ':
            return left != right
        elif op_type == 'LT':
            return left < right
        elif op_type == 'GT':
            return left > right
        elif op_type == 'LE':
            return left <= right
        elif op_type == 'GE':
            return left >= right

    def _evaluate_logical(self, op_type: str, children: List) -> bool:
        """Evaluate logical operation"""
        if op_type == 'NOT':
            return not self.evaluate(children[0])
        elif op_type == 'AND':
            return self.evaluate(children[0]) and self.evaluate(children[1])
        elif op_type == 'OR':
            return self.evaluate(children[0]) or self.evaluate(children[1])


class Statement:
    """
    Executes statements from the parse tree.

    Handles:
    - Display statements
    - Set (assignment) statements
    - If statements
    - For loops
    - While loops
    - Function calls
    - Create/Destroy (memory management)
    - Return statements
    - Exit statements
    """

    def __init__(self, env: RuntimeEnvironment, expr_evaluator: Expression):
        self.env = env
        self.expr = expr_evaluator
        self.return_value = None
        self.should_return = False
        self.should_exit = False

    def execute(self, node: Dict):
        """Execute a statement node"""
        if node is None:
            return

        node_type = node.get('type')
        value = node.get('value')
        children = node.get('children', [])

        # Handle different statement types based on the value field
        if node_type == 'STATEMENT':
            stmt_type = value

            if stmt_type == 'DISPLAY':
                self._execute_display(children)
            elif stmt_type == 'SET':
                self._execute_set(children)
            elif stmt_type == 'CALL':
                self._execute_call(children)
            elif stmt_type == 'IF':
                self._execute_if(children)
            elif stmt_type == 'FOR':
                self._execute_for(children)
            elif stmt_type == 'WHILE':
                self._execute_while(children)
            elif stmt_type == 'CREATE':
                self._execute_create(children)
            elif stmt_type == 'DESTROY':
                self._execute_destroy(children)
            elif stmt_type == 'RETURN':
                self._execute_return(children)
            elif stmt_type == 'EXIT':
                self.should_exit = True

    def _execute_display(self, children: List):
        """Execute display statement"""
        output_parts = []

        for child in children:
            child_type = child.get('type')

            # Skip the DISPLAY keyword itself
            if child_type == 'DISPLAY':
                continue
            # Skip commas
            elif child_type == 'COMMA':
                continue
            # Evaluate and add to output
            else:
                value = self.expr.evaluate(child)
                output_parts.append(str(value))

        print(' '.join(output_parts))

    def _execute_set(self, children: List):
        """Execute set (assignment) statement"""
        # Expected structure: SET, IDENTIFIER, ASSIGN, expression
        # or: SET, IDENTIFIER, ASSIGN, ADDRESS, IDENTIFIER
        # or: SET, IDENTIFIER->member, ASSIGN, expression
        # or: SET, IDENTIFIER, ASSIGN, function_call (IDENTIFIER, LPAREN, ...)
        var_name = None
        value = None

        i = 0
        while i < len(children):
            child = children[i]
            child_type = child.get('type')

            if child_type == 'SET':
                pass
            elif child_type == 'IDENTIFIER' and var_name is None:
                var_name = child.get('value')
            elif child_type == 'ARROW':
                # Handle struct member assignment: var->member = value
                # var_name should already be set
                if i + 1 < len(children):
                    member_name = children[i + 1].get('value')
                    # Find ASSIGN and get value after it
                    for j in range(i + 2, len(children)):
                        if children[j].get('type') == 'ASSIGN':
                            if j + 1 < len(children):
                                value = self.expr.evaluate(children[j + 1])
                            break
                    # Set struct member
                    if var_name and member_name and value is not None:
                        var_value = self.env.get_variable(var_name)
                        if isinstance(var_value, int):  # It's an address
                            struct_inst = self.env.dereference(var_value)
                        else:
                            struct_inst = var_value
                        if isinstance(struct_inst, StructInstance):
                            struct_inst.fields[member_name] = value
                    return
            elif child_type == 'ASSIGN':
                # Check if next is ADDRESS keyword
                if i + 1 < len(children) and children[i + 1].get('type') == 'ADDRESS':
                    # Get the identifier after ADDRESS
                    if i + 2 < len(children):
                        target_var = children[i + 2].get('value')
                        # For simulation, we'll just reference the variable
                        value = f"&{target_var}"
                # Check if next is a function call (IDENTIFIER followed by LPAREN)
                elif (i + 2 < len(children) and
                      children[i + 1].get('type') == 'IDENTIFIER' and
                      children[i + 2].get('type') == 'LPAREN'):
                    func_name = children[i + 1].get('value')
                    # For simulation, we'll create a placeholder value
                    value = f"<return_value_from_{func_name}>"
                    print(f"[FUNCTION CALL] {var_name} = {func_name}(...)")
                else:
                    # Regular expression evaluation
                    if i + 1 < len(children):
                        value = self.expr.evaluate(children[i + 1])
                break

            i += 1

        if var_name and value is not None:
            self.env.set_variable(var_name, value)

    def _execute_call(self, children: List):
        """Execute function call statement"""
        func_name = None
        args = []

        for i, child in enumerate(children):
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and func_name is None:
                func_name = child.get('value')
            elif child_type == 'USING':
                # Arguments come after USING
                for j in range(i + 1, len(children)):
                    arg_child = children[j]
                    if arg_child.get('type') not in ['USING', 'COMMA', 'CALL']:
                        arg_value = self.expr.evaluate(arg_child)
                        args.append(arg_value)

                break

        # For now, we'll skip actual function execution for library functions
        # In a real implementation, we'd call the function here
        if func_name:
            print(f"[CALL] {func_name}({', '.join(map(str, args))})")

    def _execute_if(self, children: List):
        """Execute if statement"""
        condition = None
        then_statements = []
        else_statements = []
        in_else = False

        for child in children:
            child_type = child.get('type')

            if child_type == 'CONDITION':
                # Evaluate condition
                cond_children = child.get('children', [])
                if cond_children:
                    condition = self.expr.evaluate(cond_children[0])
            elif child_type == 'THEN':
                in_else = False
            elif child_type == 'ELSE':
                in_else = True
            elif child_type == 'STATEMENT':
                if in_else:
                    else_statements.append(child)
                else:
                    then_statements.append(child)

        # Execute appropriate branch
        if condition:
            for stmt in then_statements:
                self.execute(stmt)
                if self.should_return or self.should_exit:
                    break
        else:
            for stmt in else_statements:
                self.execute(stmt)
                if self.should_return or self.should_exit:
                    break

    def _execute_for(self, children: List):
        """Execute for loop"""
        loop_var = None
        start_val = None
        end_val = None
        statements = []

        for i, child in enumerate(children):
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and loop_var is None:
                loop_var = child.get('value')
            elif child_type == 'NUMBER':
                if start_val is None:
                    start_val = int(child.get('value'))
                else:
                    end_val = int(child.get('value'))
            elif child_type == 'STATEMENT':
                statements.append(child)

        if loop_var and start_val is not None and end_val is not None:
            for i in range(start_val, end_val + 1):
                self.env.set_variable(loop_var, i)

                for stmt in statements:
                    self.execute(stmt)
                    if self.should_return or self.should_exit:
                        break

                if self.should_return or self.should_exit:
                    break

    def _execute_while(self, children: List):
        """Execute while loop"""
        condition_node = None
        statements = []

        for child in children:
            child_type = child.get('type')

            if child_type == 'CONDITION':
                condition_node = child
            elif child_type == 'STATEMENT':
                statements.append(child)

        while True:
            # Evaluate condition
            if condition_node:
                cond_children = condition_node.get('children', [])
                if cond_children:
                    condition = self.expr.evaluate(cond_children[0])
                    if not condition:
                        break
            else:
                break

            # Execute loop body
            for stmt in statements:
                self.execute(stmt)
                if self.should_return or self.should_exit:
                    break

            if self.should_return or self.should_exit:
                break

    def _execute_create(self, children: List):
        """Execute create (memory allocation) statement"""
        var_name = None
        type_name = None

        for child in children:
            child_type = child.get('type')

            if child_type == 'IDENTIFIER':
                if var_name is None:
                    var_name = child.get('value')
                else:
                    type_name = child.get('value')

        if var_name and type_name:
            # Allocate memory and store address in variable
            address = self.env.allocate_memory(type_name)
            self.env.set_variable(var_name, address)
            print(f"[CREATE] Allocated {type_name} at address {address} for {var_name}")

    def _execute_destroy(self, children: List):
        """Execute destroy (memory deallocation) statement"""
        var_name = None

        for child in children:
            child_type = child.get('type')

            if child_type == 'IDENTIFIER':
                var_name = child.get('value')
                break

        if var_name:
            # Get the address and deallocate
            try:
                address = self.env.get_variable(var_name)
                if isinstance(address, int):
                    self.env.deallocate_memory(address)
                    print(f"[DESTROY] Deallocated memory at address {address} for {var_name}")
            except Exception as e:
                print(f"[DESTROY] Warning: {e}")

    def _execute_return(self, children: List):
        """Execute return statement"""
        # Find the return value expression
        for child in children:
            if child.get('type') != 'RETURN':
                self.return_value = self.expr.evaluate(child)
                break
        self.should_return = True


class Program:
    """
    Main program class that loads and runs SCL programs.

    This class implements the required interface:
    - load(): Parse the SCL program from a parse tree file
    - run(): Execute the program
    """

    def __init__(self):
        self.env = RuntimeEnvironment()
        self.expr_evaluator = Expression(self.env, self)
        self.stmt_executor = Statement(self.env, self.expr_evaluator)
        self.parse_tree = None
        self.statements = []

    def load(self, parse_tree_file: str):
        """
        Load an SCL program from a parse tree JSON file.

        Args:
            parse_tree_file: Path to the JSON file containing the parse tree
        """
        print(f"Loading program from: {parse_tree_file}")

        with open(parse_tree_file, 'r') as f:
            data = json.load(f)

        self.parse_tree = data.get('parse_tree')

        if not self.parse_tree:
            raise RuntimeError("Invalid parse tree file")

        # Parse the program structure
        self._parse_program(self.parse_tree)

        print("Program loaded successfully")

    def _parse_program(self, program_node: Dict):
        """Parse the program node and extract functions and statements"""
        children = program_node.get('children', [])

        for child in children:
            child_type = child.get('type')

            if child_type == 'SPECIFICATIONS_SECTION':
                self._parse_specifications(child)
            elif child_type == 'FUNCTION_DEFINITIONS':
                self._parse_function_definitions(child)

    def _parse_specifications(self, spec_node: Dict):
        """Parse specifications section (structs, forward declarations)"""
        children = spec_node.get('children', [])

        for child in children:
            child_type = child.get('type')

            if child_type == 'STRUCT_DEFINITION':
                self._parse_struct_definition(child)

    def _parse_struct_definition(self, struct_node: Dict):
        """Parse a struct definition"""
        children = struct_node.get('children', [])
        struct_name = None
        fields = {}

        # Find struct name
        for i, child in enumerate(children):
            if child.get('type') == 'STRUCT':
                # Name should be next
                if i + 1 < len(children):
                    struct_name = children[i + 1].get('value')
                break

        # Find variables section
        for child in children:
            if child.get('type') == 'VARIABLES_SECTION':
                fields = self._parse_variables_section(child, extract_only=True)

        if struct_name:
            self.env.define_struct(struct_name, fields)
            print(f"Defined struct: {struct_name} with fields {list(fields.keys())}")

    def _parse_function_definitions(self, func_defs_node: Dict):
        """Parse function definitions"""
        children = func_defs_node.get('children', [])

        for child in children:
            if child.get('type') == 'FUNCTION_DEFINITION':
                self._parse_function_definition(child)

    def _parse_variables_section(self, var_section_node: Dict, extract_only=False):
        """
        Parse variables section and either declare variables or just extract type info.

        Args:
            var_section_node: The VARIABLES_SECTION node
            extract_only: If True, only extract field names/types, don't declare variables

        Returns:
            Dict of variable_name -> type_name if extract_only, else None
        """
        children = var_section_node.get('children', [])
        var_info = {}

        for child in children:
            if child.get('type') == 'VARIABLE_DEFINE':
                var_children = child.get('children', [])
                var_name = None
                var_type = None
                is_array = False
                array_size = 0

                i = 0
                while i < len(var_children):
                    vchild = var_children[i]
                    vtype = vchild.get('type')

                    if vtype == 'IDENTIFIER':
                        if var_name is None:
                            var_name = vchild.get('value')
                    elif vtype == 'ARRAY':
                        is_array = True
                        # Look for size in next few children
                        if i + 2 < len(var_children) and var_children[i + 2].get('type') == 'NUMBER':
                            array_size = int(var_children[i + 2].get('value'))
                    elif vtype in ['INTEGER', 'DOUBLE', 'FLOAT', 'CHAR', 'STRING', 'BOOLEAN', 'LONG', 'BYTE']:
                        var_type = vchild.get('value').lower()

                    i += 1

                if var_name and var_type:
                    if is_array:
                        full_type = f"array_{var_type}_{array_size}"
                        if extract_only:
                            var_info[var_name] = full_type
                        else:
                            self.env.declare_variable(var_name, full_type, [None] * array_size)
                    else:
                        if extract_only:
                            var_info[var_name] = var_type
                        else:
                            self.env.declare_variable(var_name, var_type)

        return var_info if extract_only else None

    def _parse_structures_section(self, struct_section_node: Dict):
        """Parse structures section (variable declarations with struct types)"""
        children = struct_section_node.get('children', [])

        for child in children:
            if child.get('type') == 'DEFINE_STATEMENT':
                stmt_children = child.get('children', [])
                var_name = None
                var_type = None
                is_pointer = False

                i = 0
                while i < len(stmt_children):
                    schild = stmt_children[i]
                    stype = schild.get('type')

                    if stype == 'IDENTIFIER':
                        val = schild.get('value')
                        if val == 'pointer':
                            is_pointer = True
                        elif var_name is None:
                            var_name = val
                        else:
                            var_type = val  # Type name (could be struct type or type alias)

                    i += 1

                if var_name:
                    if is_pointer:
                        self.env.declare_variable(var_name, f"pointer_{var_type}", None)
                    else:
                        self.env.declare_variable(var_name, var_type)

    def _parse_function_definition(self, func_node: Dict):
        """Parse a single function definition and store it"""
        children = func_node.get('children', [])
        func_name = None
        return_type = None
        params = []
        body_nodes = {'variables': None, 'structures': None, 'statements': None}

        i = 0
        while i < len(children):
            child = children[i]
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and func_name is None:
                func_name = child.get('value')
            elif child_type in ['INTEGER', 'DOUBLE', 'FLOAT', 'CHAR', 'STRING', 'BOOLEAN', 'LONG', 'VOID']:
                return_type = child.get('value').lower()
            elif child_type == 'PARAMETERS':
                params = self._parse_parameters(child)
            elif child_type == 'VARIABLES_SECTION':
                body_nodes['variables'] = child
            elif child_type == 'STRUCTURES_SECTION':
                body_nodes['structures'] = child
            elif child_type == 'STATEMENTS':
                body_nodes['statements'] = child

            i += 1

        if func_name:
            self.env.define_function(func_name, params, return_type, body_nodes)
            print(f"Defined function: {func_name} with return type {return_type}")

    def _parse_parameters(self, params_node: Dict):
        """Parse function parameters"""
        # For now, return empty list - parameters can be added later if needed
        # This would require parsing PARAMETER_TOKEN children
        return []

    def run(self):
        """
        Execute the loaded SCL program.

        This starts execution from the main() function.
        """
        print("\n=== Starting Program Execution ===\n")

        # Find and execute main function
        if 'main' not in self.env.functions:
            raise RuntimeError("No main function found")

        main_func = self.env.get_function('main')

        # Execute main function body
        self._execute_function('main', [])

        print("\n=== Program Execution Complete ===")

    def _execute_function(self, func_name: str, args: List):
        """Execute a function with given arguments"""
        func_def = self.env.get_function(func_name)

        # Push new scope for function
        self.env.push_scope()

        try:
            # TODO: Bind parameters to arguments

            # Declare local variables
            if func_def['body']['variables']:
                self._parse_variables_section(func_def['body']['variables'])

            # Declare local struct instances
            if func_def['body']['structures']:
                self._parse_structures_section(func_def['body']['structures'])

            # Execute statements
            if func_def['body']['statements']:
                statements_node = func_def['body']['statements']
                statement_children = statements_node.get('children', [])

                for stmt in statement_children:
                    self.stmt_executor.execute(stmt)

                    # Check for early return or exit
                    if self.stmt_executor.should_return or self.stmt_executor.should_exit:
                        break

            return_val = self.stmt_executor.return_value
            self.stmt_executor.return_value = None
            self.stmt_executor.should_return = False

            return return_val

        finally:
            # Always pop the scope
            self.env.pop_scope()


def main():
    """Main entry point for the executor"""
    if len(sys.argv) < 2:
        print("Usage: python scl_executor.py <parse_tree_file.json>")
        sys.exit(1)

    parse_tree_file = sys.argv[1]

    # Create program instance
    program = Program()

    try:
        # Load the program
        program.load(parse_tree_file)

        # Run the program
        program.run()

    except RuntimeError as e:
        print(f"Runtime Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
