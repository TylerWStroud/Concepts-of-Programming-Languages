"""
SCL Code Generator - Translates SCL parse trees to Python code

This module generates executable Python code from SCL parse trees.
The generated code is written to a .py file that can be executed directly.

Author: Tyler Stroud
"""

import json
import sys
from typing import Dict, List, Any


class CodeGenerator:
    """
    Generates Python code from an SCL parse tree.

    Translates SCL constructs to equivalent Python code:
    - Variables -> Python variables
    - Display -> print() statements
    - Set -> assignment statements
    - Functions -> Python functions
    - Structs -> Python classes
    """

    def __init__(self):
        self.output = []
        self.indent_level = 0
        self.functions = []
        self.structs = []

    def indent(self):
        """Get current indentation string"""
        return "    " * self.indent_level

    def emit(self, code: str):
        """Emit a line of code with proper indentation"""
        if code.strip():
            self.output.append(self.indent() + code)
        else:
            self.output.append("")

    def generate(self, parse_tree_file: str, output_file: str):
        """
        Generate Python code from parse tree and write to file.

        Args:
            parse_tree_file: Path to JSON parse tree
            output_file: Path to output Python file
        """
        print(f"Loading parse tree from: {parse_tree_file}")

        with open(parse_tree_file, 'r') as f:
            data = json.load(f)

        parse_tree = data.get('parse_tree')

        # Generate header
        self.emit("#!/usr/bin/env python3")
        self.emit('"""')
        self.emit("Generated Python code from SCL source")
        self.emit("Auto-generated by scl_codegen.py")
        self.emit('"""')
        self.emit("")

        # Generate code from parse tree
        self._generate_program(parse_tree)

        # Add main execution
        self.emit("")
        self.emit("if __name__ == '__main__':")
        self.indent_level += 1
        self.emit("main()")
        self.indent_level -= 1

        # Write to file
        code = '\n'.join(self.output)
        with open(output_file, 'w') as f:
            f.write(code)

        print(f"Generated Python code saved to: {output_file}")
        print(f"Total lines: {len(self.output)}")

    def _generate_program(self, program_node: Dict):
        """Generate code for entire program"""
        children = program_node.get('children', [])

        for child in children:
            child_type = child.get('type')

            if child_type == 'SPECIFICATIONS_SECTION':
                self._generate_specifications(child)
            elif child_type == 'FUNCTION_DEFINITIONS':
                self._generate_function_definitions(child)

    def _generate_specifications(self, spec_node: Dict):
        """Generate code for specifications section"""
        children = spec_node.get('children', [])

        for child in children:
            child_type = child.get('type')

            if child_type == 'STRUCT_DEFINITION':
                self._generate_struct(child)

        if self.structs:
            self.emit("")

    def _generate_struct(self, struct_node: Dict):
        """Generate Python class for struct"""
        children = struct_node.get('children', [])
        struct_name = None
        fields = []

        # Find struct name
        for i, child in enumerate(children):
            if child.get('type') == 'STRUCT':
                if i + 1 < len(children):
                    struct_name = children[i + 1].get('value')
                break

        # Find fields
        for child in children:
            if child.get('type') == 'VARIABLES_SECTION':
                fields = self._extract_fields(child)

        if struct_name:
            self.emit(f"class {struct_name}:")
            self.indent_level += 1
            self.emit(f'"""Struct: {struct_name}"""')
            self.emit("def __init__(self):")
            self.indent_level += 1

            if fields:
                for field_name, field_type in fields.items():
                    default_val = self._get_default_value(field_type)
                    self.emit(f"self.{field_name} = {default_val}")
            else:
                self.emit("pass")

            self.indent_level -= 2
            self.emit("")
            self.structs.append(struct_name)

    def _extract_fields(self, var_section_node: Dict) -> Dict[str, str]:
        """Extract field names and types from variables section"""
        children = var_section_node.get('children', [])
        fields = {}

        for child in children:
            if child.get('type') == 'VARIABLE_DEFINE':
                var_children = child.get('children', [])
                var_name = None
                var_type = None

                for vchild in var_children:
                    vtype = vchild.get('type')
                    if vtype == 'IDENTIFIER' and var_name is None:
                        var_name = vchild.get('value')
                    elif vtype in ['INTEGER', 'DOUBLE', 'FLOAT', 'CHAR', 'STRING']:
                        var_type = vchild.get('value')

                if var_name and var_type:
                    fields[var_name] = var_type

        return fields

    def _get_default_value(self, var_type: str) -> str:
        """Get Python default value for a type"""
        type_lower = var_type.lower()
        if type_lower in ['integer', 'long']:
            return '0'
        elif type_lower in ['double', 'float']:
            return '0.0'
        elif type_lower == 'char':
            return "''"
        elif type_lower == 'string':
            return '""'
        elif type_lower == 'boolean':
            return 'False'
        else:
            return 'None'

    def _generate_function_definitions(self, func_defs_node: Dict):
        """Generate Python functions"""
        children = func_defs_node.get('children', [])

        for child in children:
            if child.get('type') == 'FUNCTION_DEFINITION':
                self._generate_function(child)

    def _generate_function(self, func_node: Dict):
        """Generate a single Python function"""
        children = func_node.get('children', [])
        func_name = None
        variables = []
        statements_node = None

        # Extract function name and body
        for child in children:
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and func_name is None:
                func_name = child.get('value')
            elif child_type == 'VARIABLES_SECTION':
                variables = self._extract_variables(child)
            elif child_type == 'STATEMENTS':
                statements_node = child

        if func_name:
            # Function signature
            self.emit(f"def {func_name}():")
            self.indent_level += 1
            self.emit(f'"""Function: {func_name}"""')

            # Variable declarations
            if variables:
                for var_name, var_type in variables.items():
                    default_val = self._get_default_value(var_type)
                    self.emit(f"{var_name} = {default_val}")
                self.emit("")

            # Function body
            if statements_node:
                self._generate_statements(statements_node)
            else:
                self.emit("pass")

            self.indent_level -= 1
            self.emit("")
            self.functions.append(func_name)

    def _extract_variables(self, var_section_node: Dict) -> Dict[str, str]:
        """Extract variable declarations"""
        children = var_section_node.get('children', [])
        variables = {}

        for child in children:
            if child.get('type') == 'VARIABLE_DEFINE':
                var_children = child.get('children', [])
                var_name = None
                var_type = None

                for vchild in var_children:
                    vtype = vchild.get('type')
                    if vtype == 'IDENTIFIER' and var_name is None:
                        var_name = vchild.get('value')
                    elif vtype in ['INTEGER', 'DOUBLE', 'FLOAT', 'CHAR', 'STRING', 'BOOLEAN']:
                        var_type = vchild.get('value')

                if var_name and var_type:
                    variables[var_name] = var_type

        return variables

    def _generate_statements(self, statements_node: Dict):
        """Generate code for statements"""
        children = statements_node.get('children', [])

        for stmt in children:
            self._generate_statement(stmt)

    def _generate_statement(self, stmt_node: Dict):
        """Generate code for a single statement"""
        stmt_type = stmt_node.get('value')
        children = stmt_node.get('children', [])

        if stmt_type == 'DISPLAY':
            self._generate_display(children)
        elif stmt_type == 'SET':
            self._generate_set(children)
        elif stmt_type == 'CALL':
            self._generate_call(children)
        elif stmt_type == 'IF':
            self._generate_if(children)
        elif stmt_type == 'FOR':
            self._generate_for(children)
        elif stmt_type == 'WHILE':
            self._generate_while(children)
        elif stmt_type == 'CREATE':
            self._generate_create(children)
        elif stmt_type == 'DESTROY':
            self._generate_destroy(children)
        elif stmt_type == 'RETURN':
            self._generate_return(children)
        elif stmt_type == 'EXIT':
            self.emit("return  # exit")

    def _generate_display(self, children: List):
        """Generate print statement"""
        parts = []

        for child in children:
            child_type = child.get('type')

            if child_type == 'DISPLAY':
                continue
            elif child_type == 'COMMA':
                continue
            elif child_type == 'STRING':
                parts.append(f'"{child.get("value")}"')
            elif child_type == 'IDENTIFIER':
                parts.append(child.get('value'))
            elif child_type in ['NUMBER', 'FLOAT_NUMBER']:
                parts.append(str(child.get('value')))

        if parts:
            self.emit(f"print({', '.join(parts)})")
        else:
            self.emit("print()")

    def _generate_set(self, children: List):
        """Generate assignment statement"""
        var_name = None
        value_expr = None

        i = 0
        while i < len(children):
            child = children[i]
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and var_name is None:
                var_name = child.get('value')
            elif child_type == 'ASSIGN':
                # Get value after =
                if i + 1 < len(children):
                    value_expr = self._generate_expression(children[i + 1])
                break

            i += 1

        if var_name and value_expr:
            self.emit(f"{var_name} = {value_expr}")

    def _generate_expression(self, expr_node: Dict) -> str:
        """Generate expression code"""
        expr_type = expr_node.get('type')
        value = expr_node.get('value')

        if expr_type == 'NUMBER':
            return str(value)
        elif expr_type == 'FLOAT_NUMBER':
            return str(value)
        elif expr_type == 'STRING':
            return f'"{value}"'
        elif expr_type == 'IDENTIFIER':
            return value
        elif expr_type == 'ADDRESS':
            return '"&address"'
        else:
            return str(value) if value else 'None'

    def _generate_call(self, children: List):
        """Generate function call"""
        func_name = None
        args = []

        for i, child in enumerate(children):
            child_type = child.get('type')

            if child_type == 'IDENTIFIER' and func_name is None:
                func_name = child.get('value')
            elif child_type == 'USING':
                # Collect arguments after USING
                for j in range(i + 1, len(children)):
                    arg_child = children[j]
                    if arg_child.get('type') not in ['USING', 'COMMA', 'CALL']:
                        arg_expr = self._generate_expression(arg_child)
                        args.append(arg_expr)
                break

        if func_name:
            args_str = ', '.join(args) if args else ''
            self.emit(f"# CALL: {func_name}({args_str})")

    def _generate_if(self, children: List):
        """Generate if statement"""
        self.emit("# IF statement")
        self.emit("pass")

    def _generate_for(self, children: List):
        """Generate for loop"""
        loop_var = None
        start_val = None
        end_val = None

        for child in children:
            child_type = child.get('type')
            if child_type == 'IDENTIFIER' and loop_var is None:
                loop_var = child.get('value')
            elif child_type == 'NUMBER':
                if start_val is None:
                    start_val = child.get('value')
                else:
                    end_val = child.get('value')

        if loop_var and start_val and end_val:
            self.emit(f"for {loop_var} in range({start_val}, {int(end_val) + 1}):")
            self.indent_level += 1
            self.emit("pass  # loop body")
            self.indent_level -= 1

    def _generate_while(self, children: List):
        """Generate while loop"""
        self.emit("while True:")
        self.indent_level += 1
        self.emit("pass  # loop body")
        self.indent_level -= 1

    def _generate_create(self, children: List):
        """Generate memory allocation"""
        var_name = None
        type_name = None

        for child in children:
            child_type = child.get('type')
            if child_type == 'IDENTIFIER':
                if var_name is None:
                    var_name = child.get('value')
                else:
                    type_name = child.get('value')

        if var_name:
            if type_name in self.structs:
                self.emit(f"{var_name} = {type_name}()  # CREATE")
            else:
                self.emit(f"{var_name} = None  # CREATE {type_name}")

    def _generate_destroy(self, children: List):
        """Generate memory deallocation"""
        var_name = None

        for child in children:
            if child.get('type') == 'IDENTIFIER':
                var_name = child.get('value')
                break

        if var_name:
            self.emit(f"{var_name} = None  # DESTROY")

    def _generate_return(self, children: List):
        """Generate return statement"""
        return_val = None

        for child in children:
            if child.get('type') != 'RETURN':
                return_val = self._generate_expression(child)
                break

        if return_val:
            self.emit(f"return {return_val}")
        else:
            self.emit("return")


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python scl_codegen.py <parse_tree_file.json> [output_file.py]")
        sys.exit(1)

    parse_tree_file = sys.argv[1]

    # Generate output filename
    if len(sys.argv) >= 3:
        output_file = sys.argv[2]
    else:
        # Default: replace _parse_tree.json with .py
        if parse_tree_file.endswith('_parse_tree.json'):
            output_file = parse_tree_file.replace('_parse_tree.json', '_generated.py')
        else:
            output_file = parse_tree_file.replace('.json', '_generated.py')

    # Generate code
    generator = CodeGenerator()

    try:
        generator.generate(parse_tree_file, output_file)
        print(f"\nâœ“ Code generation complete!")
        print(f"\nTo run the generated code:")
        print(f"  python {output_file}")

    except FileNotFoundError:
        print(f"Error: Parse tree file '{parse_tree_file}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
